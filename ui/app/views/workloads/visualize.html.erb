<script src="http://d3js.org/d3.v3.min.js"></script>
<style>

#visualization
{
border:2px solid;
border-radius:25px;
}

node {
  stroke: #fff;
  stroke-width: 1.5px;
}

path.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

text {
  fill: #000;
  font: 10px sans-serif;
  pointer-events: none;
}

svg body {
  color: transparent;
background: transparent;
}
svg div { 
  border-radius: 8px;
}
.table td{
padding:0px;
}
</style>
<body>

<div id="visualization">
</div>
<script>

var json=<%=raw @jsondata.to_json%>;
var width = 1100;
var height = 600;
var color = d3.scale.category10();
var force=d3.layout.force()
var nodes=json["jobs"];
var links=[];
//generate links dynamically with dependentChildren field
for (var i=0;i<nodes.length;i++){
  for (var j=0;j<nodes[i]["dependentChildren"].length;j++){
      //get the children field of each node
  //set a link between the current node i and the index of the target node, found by looping
  links.push({"source":i,"target":findIndexById(nodes[i]["dependentChildren"][j])});
  }
}

function findIndexById(id){
for (var i=0;i<nodes.length;i++){
  if (nodes[i].jobId==id){
    return i;
  }
}
return -1;
}

var svg = d3.select("#visualization").append("svg")
  .attr("width", width)
  .attr("height", height);

console.log(nodes);

//make arrows
svg.append("svg:defs").selectAll("marker")
    .data(["end"])
  .enter().append("svg:marker")
    .attr("id", String)
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 20)
    .attr("refY", -2.0)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("svg:path")
    .attr("d", "M0,-5L10,0L0,5");

force
    .nodes(nodes)
    .links(links)
    .size([width, height])
    .linkDistance(300)
    .charge(-1000)
    .on("tick", tick)
    .start();

//create paths
path = svg.append("svg:g").selectAll("path")
    .data(force.links())
  .enter().append("svg:path")
    .attr("class", "link")
    .attr("marker-end", function(d) { return "url(#end)"; })
    .attr("id", 
              function(d) { 
                 return "path"+d.source.index+"_"+d.target.index; 
              }) 
       .attr("d", 
              function(d) { 
                 return moveto(d) + lineto(d); 
              }); 

var pi=Math.PI;
//find number of varieties in node
//figure out how many are graph, relational, nested
//define color constants for each type, relational=blue, graph=orange, nested=green
var varietyColorMap={"relational":0, "graph":1, "nested":2};

// add legend   
  var legend = svg.append("g")
    .attr("x", width - 65)
    .attr("y", 25)
    .attr("height", 100)
    .attr("width", 100);

var offset=0;
  for (var key in varietyColorMap){
        legend.append("rect")
          .attr("x", 100)
          .attr("y", 100+offset*25)
          .attr("width", 10)
          .attr("height",10)
          .style("fill", color(varietyColorMap[key]));
        
        legend.append("text")
          .attr("x", 115)
          .attr("y", 100 + offset*25 + 8)
          .attr("height",30)
          .attr("width",100)
          .style("fill", color(varietyColorMap[key]))
          .text(key);
      offset+=1;
      }

for (var i=0;i<nodes.length;i++){
  hash={"relational":0, "graph":0, "nested":0};
  for (var j=0;j<nodes[i].rootInputPath.length;j++){
    for (var key in hash){
       if (nodes[i].rootInputPath[j].indexOf(key)>=0){
        hash[key]=hash[key]+1;
       }
    }
}
array=[];
for (var key in hash){
  obj={};
  obj["group"]=key;
  obj["value"]=hash[key]
  array.push(obj);
}
//create new field dataVarieties to track counts
nodes[i]["dataVarieties"]=array;
}

   var pie = d3.layout.pie()
        .sort(null)
        .value(function(d) { return d.value; });

  var arc = d3.svg.arc()
        .outerRadius(10)
        .innerRadius(0);

        // define the nodes
node = svg.selectAll("node")
  .data(force.nodes())
  .enter()
  .append("g")
    .attr("class", "node")
    .call(force.drag); 
/*
//create expandall button
var expandAll=svg.append("g");
expandAll.append("svg:rect")
    .attr('fill',"green")
    .attr('x',50)
    .attr('y',30)
    .attr('width',50)
    .attr('height',30)
    .attr('rx',5)
    .attr('ry',5);
expandAll
.append("text")
.attr('style',"fill:white")
.text("Expand all")
.attr('x',50)
.attr('y',50);

expandAll.on("click",function(d){
  toggle(svg.selectAll("div"));
});
*/

//draw variety circle
    node.selectAll("path")
        .data(function(d, i) {return pie(d.dataVarieties); })
        .enter()
        .append("svg:path")
        .attr("d", arc)
        .attr("transform", "translate(" + 0 + "," + 0 + ")")
        .attr("fill", function(d, i) { return color(varietyColorMap[d.data.group]); });

function stringifyArray(input){
var string="";
for (var i=0;i<input.length;i++){
  string+=input[i]+"<br>";
}
return string;
}

function stringifyVarieties(input){
  var string="";
  for (var i=0;i<input.length;i++){
    if (input[i].value>0){
      string+=input[i].group+"/";
    }
}
//drop trailing slash
return string.slice(0, - 1);
}

//add workflow data
svg.append("text")
        .attr("x", 100)             
        .attr("y", 50)
        .text("Workflow ID: "+json["workflowId"]);
svg.append("text")
        .attr("x", 100)             
        .attr("y", 60)
        .text("Runtime: "+(json["endTime"]-json["startTime"]));
svg.append("text")
        .attr("x", 100)             
        .attr("y", 70)
        .text("Number of jobs: "+json["numJobs"]);
svg.append("text")
        .attr("x", 100)             
        .attr("y", 80)
        .text("Execution Engine: "+json["executionEngine"]);

var div = node
.append("foreignObject").attr("width", 250).attr("height", 400)
    .attr("y", -100)
    .attr("x", 20)
  .append("xhtml:body")
  .append("div")
    .style("color", "#FFFFFF")
    .style("background-color",function(d) { return color(0);})
    .style("font-size", "10px")
  .html(function(d) { 
    html="<table class='table table-bordered'>";
    var runTime=d.endTime-d.startTime;
    if (d.mapTasks!=null && d.reduceTasks!=null){
      html=html+"<tr><td>Map/Reduce</td><td>"+d.mapTasks+" map/"+d.reduceTasks+" reduce</td></tr>"
    }
    html=html+"<tr><td>Job ID:</td><td>"+d.jobId+"</td></tr><tr><td>Runtime:</td><td>"+runTime+"</td></tr><tr><td>Parallelism:</td><td>"+d.parallelism+"</td></tr><tr><td>Start Time:</td><td>"+d.startTime+"</td></tr><tr><td>End Time:</td><td>"+d.endTime+"</td></tr><tr><td>Variety:</td><td>"+stringifyVarieties(d.dataVarieties)+"</td></tr><tr><td>Input:</td><td>"+stringifyArray(d.rootInputPath);
    html+="</table>";
    return html;
  });

//display div on dblclick
node.on("dblclick", function(d) {
  toggle(d3.select(this).selectAll("div"));
});

function toggle(e) {
if(e.style("display") == 'block')
e.style("display", "none");
else
e.style("display", 'block');
tick();
}

/*
//fix a node to the left
  for (var i=0;i<nodes.length;i++){
    if (nodes[i].name=="INPUT"){
            var inp=i;
    }
  }
  nodes[inp].x=50;
  nodes[inp].y=height/2;
  nodes[inp].px = nodes[inp].x;
  nodes[inp].py = nodes[inp].y;
  nodes[inp].fixed=1;
  */

function moveto (d) { 
     return "M"+d.source.x+","+d.source.y; 
  }; 

  function lineto (d) { 
     return " L"+d.target.x+","+d.target.y; 
  }; 

// add the lines, dr=0 forces them to be straight
function tick() {

//does curved lines
    path
    .attr("d", function(d) {
            var dx = d.target.x - d.source.x,
            dy = d.target.y-d.source.y,
            dr = Math.sqrt(dx*dx+dy*dy);
        return "M" + 
            d.source.x + "," + 
            d.source.y + "A" + 
            dr + "," + dr + " 0 0,1 " + 
            d.target.x + "," + 
            d.target.y;
            });

    node
        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

}

</script>